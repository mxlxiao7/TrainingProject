这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。

    面向切面编程（AOP是Aspect Oriented Program的首字母缩写） ，我们知道，面向对象的特点是继承、多态和封装。
而封装就要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。实际上也就是说，让不同的类设计不同的方
法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可重用。但是人们也发现，在分散代
码的同时，也增加了代码的重复性。什么意思呢？比如说，我们在两个类中，可能都需要在每个方法中做日志。按面向对象的
设计方法，我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但就是因为面向对象的设计让类与类之
间无法联系，而不能将这些重复的代码统一起来。
    也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样
一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要
的时候，随意地加入代码呢？这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。
    一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们
就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。这样看来，AOP其实只
是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。
如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的。
AOP在编程历史上可以说是里程碑式的，对OOP编程是一种十分有益的补充。

    一些示例的 cross-cutting concerns 如下：

    *   **日志**
    *   **持久化**
    *   **性能监控**
    *   **数据校验**
    *   **缓存**


常用的aop框架有：

#####AspectJ:
AspectJ是一个面向切面的框架，它扩展了Java语言。AspectJ定义了AOP语法所以它有一个专门的编译器用来生成遵守Java字节
编码规范的Class文件。和ASM一样，Aspectj有静态编译和动态编译的优点，供程序员选择。另外Aspectj其编码更为简洁，是
Android开发中，实现AOP的首选。
*优点：可以织入绝所有类；两者生成方式，可以根据需求选择；编写简单，功能强大
*缺点：需要使用ajc编译器编译，ajc编译器是java编译器的扩展，具有其所有功能


#####CGlib: （android无法使用）
#####CGlib-for-android
在运行期，目标类加载后，动态构建字节码文件生成目标类的子类，将切面逻辑加入到子类中，没有接口也可以织入，
但扩展类的实例方法为final时，则无法进行织入。可以使用Cglib来实现动态字节码生成，这是一个强大的，高性能，
高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。CGLIB包的底层是通过使用一个小而快的字节
码处理框架ASM，来转换字节码并生成新的类。
*优点：可以织入没有接口的类；运行时生成，减少不必要的生成开销；通过字节码生成子类，而不是反射方式去调用代理类
*缺点：不能织入final方法；运行时生成子类，说明会有生成开销，并且可能生成大量子类


#####Javassist for Android:
Javassist是一个编辑字节码的框架，可以让你很简单地操作字节码。它可以在运行期定义或修改Class。
使用Javassist实现AOP的原理是在字节码加载前直接修改需要切入的方法。这比使用Cglib实现AOP更加高效，并且没太多限制.
*优点：可以织入绝大部分类；运行时生成，减少不必要的生成开销；通过将切面逻辑写入字节码，减少了生成子类的开销，不会产生过多子类
*缺点：运行时加入切面逻辑，产生开销；


#####DexMaker: Dalvik 虚拟机上，在编译期或者运行时生成代码的 Java API。


#####ASM:
#####ASMDEX: 一个类似 ASM 的字节码操作库，运行在Android平台，操作Dex字节码。
ASM是一个 Java 字节码操控框架。它能够以二进制形式修改已有类或者动态生成类。ASM 可以直接产生二进制 class 文件，也
可以在类被加载入 Java 虚拟机之前动态改变类行为。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根
据用户要求生成新类。从上面的描述可以看出，ASM可以在编译期直接修改编译出的字节码文件，也可以像javassit一样，在运行
期，类文件加载前，去修改字节码。两者的区别在于，一个将所有需要AOP的类都事先修改了，一个在运行时需要才去修改。
*优点：可以织入绝所有类；两者生成方式，可以根据需求选择
*缺点：修改字节码，需要对class文件比较熟悉，编写过程复杂


#####Java Proxy:
有过java开发经验的朋友都知道，java通过实现InvocationHandler接口，可以实现对一个类的动态代理，通过动态代理，
我们可以生成代理类从而在代理类方法中，在执行被代理类方法前后，添加自己的实现内容，从而实现Aop。
*优点：动态代理java自身支持，不需要引入外部库，在运行期通过接口动态生成代理类
*缺点：首先代理类必须实现一个接口，如果没实现接口会抛出一个异常。第二性能影响，因为动态代理使用反射的机制实现的，首先反射肯定比直接调用要慢

#####epic
田维术在他的epic项目终于实现了在Art虚拟机上的运行时Method AOP功能（Dexposed的Art版本）！
#####Xposed:
#####Dexposed: 是基于久负盛名的开源Xposed框架实现的一个Android平台上功能强大的无侵入式运行时AOP框架。
Dexposed虽然很强大，但是但是但是，它有个致命的缺点，就是它只能支持Android Dalvik虚拟机！what? 现在的Android虚拟机都是Art虚拟机了
*优点: 可以动态监控和系统通信的各种方法。
*缺点: 不支持5.0以上手机


#####APT:
自定义一个AbstractProcessor，在编译期去解析编译的类，并且根据需求生成一个实现了特定接口的子类(代理类)，和JDK动
态代理不同的是，代理类是在编译期生成的。常见的一些Android的IOC框架中有大量应用(就是通过注解代替findviewbyid等方
法)。 这里顺便说一句，目前Android注解解析框架主要有两种实现方法，一种是运行期通过反射去解析当前类，注入相应要运行
的方法，一种是在编译期生成类的代理类，在运行期直接调用代理类的代理方法。APT指的是后者。这两种实现方式，后者消耗更少，
但是会生成大量代理类。
*优点：可以织入绝所有类；编译期代理，减少运行时消耗
*缺点：需要使用apt编译器编译；需要手动拼接代理的代码(其实是整个字符串)；生成大量代理类